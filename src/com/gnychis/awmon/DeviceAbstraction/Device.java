package com.gnychis.awmon.DeviceAbstraction;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import org.apache.commons.lang3.builder.EqualsBuilder;

import android.os.Parcel;
import android.os.Parcelable;


/**
 * A device is a physical thing.  Like a laptop, an access point, etc.  It can have multiple radios attached
 * which we save and represent as interfaces.
 * 
 * @author George Nychis (gnychis)
 */
public class Device implements Parcelable {
	
	public enum Mobility {		// Possible types of radios that we support
		UNKNOWN,
		MOBILE,
		FIXED,
	}

	List<Interface> _interfaces;	// Keep track of each radio detected
	private String _userName;		// A name for the device, could be user generated?
	Mobility _mobile;
	private int _deviceKey;		// A unique key generated by a random number for this device
	boolean _internal;				// Whether the device is internal (belongs to user) or not.
		
	public Device() {
		_interfaces = new ArrayList<Interface>();
		_userName = null;
		_mobile=Device.Mobility.UNKNOWN;
		_internal=false;
		_deviceKey = generateKey();
	}
	
	public Device(List<Interface> interfaces) {
		_interfaces = interfaces;
		_userName = null;
		_mobile=Device.Mobility.UNKNOWN;
		_internal=false;
		_deviceKey = generateKey();
	}
	
	@Override
	public boolean equals(Object obj) {
		
        if (obj == null)
            return false;
        if (obj == this)
            return true;
        if (obj.getClass() != getClass())
            return false;
        
        Device device = (Device) obj;
        
        return new EqualsBuilder().
                append(_userName, device._userName).
                append(_mobile, device._mobile).
                append(_deviceKey, device._deviceKey).
                append(_internal, device._internal).
                append(_interfaces, device._interfaces).
                isEquals();
	}
	
	/** Sets the mobility state of the device
	 * @param m the state to set the mobility to
	 */
	public void setMobility(Mobility m) {
		_mobile=m;
	}
	
	/**
	 * Returns the state of the device's mobility
	 * @return the mobile state of the device
	 */
	public Mobility getMobility() {
		return _mobile;
	}
	
	/**
	 * Returns the device's unique key that was randomly generated.
	 * @return the device key.
	 */
	public int getKey() { return _deviceKey; }
	
	
	/** Sets whether or not the device is internal (the user's) or not.
	 * @param isInternal true if internal, false otherwise.
	 */
	public void setInternal(boolean isInternal) {
		_internal=isInternal;
	}
	
	/** Gets the state of whether the device is internal or not.
	 * @return true if the device is internal, false otherwise
	 */
	public boolean getInternal() {
		return _internal;
	}
	/** Stores the user specified name for the device.
	 * @param name the name to be stored
	 */
	public void setUserName(String name) {
		_userName = name;
	}
	
	/** Returns the name for the device that was specified by the user, if there was one.
	 * @return the user's specified name
	 */
	public String getUserName() {
		return _userName;
	}
	
	/** 
	 * Get the list of interfaces that are associated with the device.
	 * 
	 * @return a list of interfaces
	 */
	public List<Interface> getInterfaces() {
		return _interfaces;
	}
	
	/** Adds whatever interfaces it can from the given list to the device.
	 * @param interfaces the interfaces to add
	 */
	public void addInterfaces(ArrayList<Interface> interfaces) {
		for(Interface i : interfaces)
			addInterface(i);
	}
	
	
	/** Be careful, this should only be used by the database.  Otherwise, keys
	 * are randomly generated and properly passed around.
	 * @param value the value to set
	 */
	public void setKey(int value) { _deviceKey=value; }
	
	/** 
	 * Tries to add the specified interface to this device.  This will
	 * fail if the interface already belongs.  This is checked by MAC address.
	 * @param iface the interface to add
	 * @return true if
	 */
	public boolean addInterface(Interface iface) {
		
		for(Interface i : _interfaces)
			if(iface._MAC.equals(i._MAC))
				return false;
		
		_interfaces.add(iface);
		
		return true;
	}
	
	/** This method generates a random long value which can be used for Interface
	 * keys to track them as they get "copied" but we need unique values for them
	 * that are persistent.
	 * @return returns a random long for use as a key
	 */
	public static int generateKey() {
		Random r = new Random();
		return r.nextInt();
	}
	
	// ********************************************************************* //
	// This code is to make this class parcelable and needs to be updated if
	// any new members are added to the Device class
	// ********************************************************************* //
    public int describeContents() {
        return this.hashCode();
    }

    public void writeToParcel(Parcel dest, int parcelableFlags) {
    	dest.writeList(_interfaces);
    	dest.writeString(_userName);
    	dest.writeInt(_mobile.ordinal());
    	dest.writeInt(_deviceKey);
    	dest.writeInt((_internal) ? 1 : 0);
    }

    public static final Parcelable.Creator<Device> CREATOR = new Parcelable.Creator<Device>() {
    	public Device createFromParcel(Parcel in) {
    		return new Device(in);
    	}

		public Device[] newArray(int size) {
			return new Device[size];
		}
    };

    private Device(Parcel source) {
    	_interfaces = new ArrayList<Interface>();
    	source.readList(_interfaces, this.getClass().getClassLoader());
    	_userName = source.readString();
    	_mobile = Device.Mobility.values()[source.readInt()];
    	_deviceKey = source.readInt();
    	_internal = (source.readInt()==1) ? true : false;
    }

}
